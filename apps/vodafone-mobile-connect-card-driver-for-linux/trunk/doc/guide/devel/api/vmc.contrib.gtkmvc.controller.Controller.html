<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>API docs for &ldquo;vmc.contrib.gtkmvc.controller.Controller&rdquo;</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
    
    
  </head>
  <body>
    <h1 class="class">Class v.c.g.c.Controller(<a href="vmc.contrib.gtkmvc.observer.Observer.html">Observer</a>):</h1>
    <p>
      <span id="part">Part of <a href="vmc.html">vmc</a>.<a href="vmc.contrib.html">contrib</a>.<a href="vmc.contrib.gtkmvc.html">gtkmvc</a>.<a href="vmc.contrib.gtkmvc.controller.html">controller</a></span>
      
      <a href="classIndex.html#vmc.contrib.gtkmvc.controller.Controller">View In Hierarchy</a>
    </p>
    <div>
      
    </div>
    <div><p>We put all of our gtk signal handlers into a class.  This lets us bind 
all of them at once, because their names are in the class dict.  This class
automatically register its instances as observers into the corresponding 
model.  Also, when a view is created, the view calls method register_view, 
which can be oveloaded in order to connect signals and perform other 
specific operation. A controller possibly handles and contains also a set 
of adapters that makes easier to connect widgets and observable properties 
into the model.</p>
parameter spurious controls the way spurious value change notifications 
are handled. If True, assignments to observable properties that do not 
actually change the value are notified anyway.
<table class="fieldTable"></table></div>
    
    
    <div id="splitTables">
      <table class="children sortable" id="id890">
  
  
  
  
  <tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.gtkmvc.controller.Controller.html#__init__">__init__</a></td>
    <td><span>When parameter spurious is set to False
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.gtkmvc.controller.Controller.html#register_view">register_view</a></td>
    <td><span>This method is called by the framework when registering a
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.gtkmvc.controller.Controller.html#register_adapters">register_adapters</a></td>
    <td><span>This method is called by register_view during view
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.gtkmvc.controller.Controller.html#adapt">adapt</a></td>
    <td><span>Adapts a set of (observable) properties and a set of
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.gtkmvc.controller.Controller.html#__create_adapters__">__create_adapters__</a></td>
    <td><span>Private service that looks at property and widgets types,
</span></td>
  </tr>
  
</table>
      
        <p>
          Inherited from <a href="vmc.contrib.gtkmvc.observer.Observer.html">Observer</a>:
        </p>
        <table class="children sortable" id="id891">
  
  
  
  
  <tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.gtkmvc.observer.Observer.html#register_model">register_model</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.gtkmvc.observer.Observer.html#accepts_spurious_change">accepts_spurious_change</a></td>
    <td><span>Returns True if this observer is interested in receiving
</span></td>
  </tr><tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.gtkmvc.observer.Observer.html#unregister_model">unregister_model</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.gtkmvc.observer.Observer.html#__del__">__del__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.gtkmvc.observer.Observer.html#get_model">get_model</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
  
</table>
      
      
    </div>
    
    
    
    <div class="function">
        <a name="vmc.contrib.gtkmvc.controller.Controller.__init__"></a>
        <a name="__init__"></a>
        <div class="functionHeader">
        
        def __init__(self, model, spurious=False):
        
      </div>
        <div class="functionBody">
          <div class="interfaceinfo">overrides <a href="vmc.contrib.gtkmvc.observer.Observer.html#__init__">vmc.contrib.gtkmvc.observer.Observer.__init__</a></div>
          <div><p>When parameter spurious is set to False (default value) the observer 
declares that it is not interested in receiving value-change notifications 
when property's value does not really change. This happens when a property 
got assigned to a value that is the same it had before being assigned.</p>
<p>A notification was used to be sent to the observer even in this 
particular condition, because spurious (non-changing) assignments were used
as signals when signals were not supported by early version of the 
framework. The observer was in charge of deciding what to do with spurious 
assignments, by checking if the old and new values were different at the 
beginning of the notification code. With latest version providing new 
notification types like signals, this requirement seems to be no longer 
needed, and delivering a notification is no longer a sensible 
behaviour.</p>
This is the reason for providing parameter spurious that changes the 
previous behaviour but keeps availability of a possible backward compatible
feature.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.gtkmvc.controller.Controller.register_view"></a>
        <a name="register_view"></a>
        <div class="functionHeader">
        
        def register_view(self, view):
        
      </div>
        <div class="functionBody">
          
          <div>This method is called by the framework when registering a view. Derived 
classes can exploit this call to connect signals manually, create and 
connect treeview, textview, etc.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.gtkmvc.controller.Controller.register_adapters"></a>
        <a name="register_adapters"></a>
        <div class="functionHeader">
        
        def register_adapters(self):
        
      </div>
        <div class="functionBody">
          
          <div>This method is called by register_view during view registration process,
when it is time to possibly create all adapters. model and view can safely 
be taken from self.model and self.view. Derived classes can specilize this 
method. In this implementation the method does nothing.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.gtkmvc.controller.Controller.adapt"></a>
        <a name="adapt"></a>
        <div class="functionHeader">
        
        def adapt(self, *args):
        
      </div>
        <div class="functionBody">
          
          <pre>Adapts a set of (observable) properties and a set of
widgets, by connecting them.

This method can be used to simplify the creation of one or
more adapters, by letting the framework do most of the work
needed to connect ('adapt') properties from one hand, and
widgets on the other.

This method is provided in three flavours:

1. An instance of an Adapter class can be created by the
   caller and passed as a unique argument. The adapter must
   be already fully configured.

2. The name of a model's property is passed as a unique
   argument.  A correponding widget name is searched and if
   found, an adapter is created. Name matching is performed
   by searching into view's widget names for words that end
   with the given property name. Matching is case
   insensitive and words can be separated by spaces,
   underscore (_) and CapitalizedWords. For example property
   'prop' will match widget 'cb_prop'. If no matches or
   multiple matches are found, a ValueError will be raised.
   The way names are matched can be customized by deriving
   method match_prop_name.

3. Two strings can be passed, respectively containing the
   name of an observable property in the model, and the name
   of a widget in the view.

Flavour 1 allows for a full control, but flavour 2 and 3
make easier to create adpaters with basic (default)
behaviour.

This method can be called into the method register_adapters
which derived classes can specialise.</pre>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.gtkmvc.controller.Controller.__match_prop_name"></a>
        <a name="__match_prop_name"></a>
        <div class="functionHeader">
        
        def __match_prop_name(self, prop_name, wid_name):
        
      </div>
        <div class="functionBody">
          
          <div>Used internally when searching for a suitable widget. To customize its 
behaviour, re-implement this method into derived classes
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.gtkmvc.controller.Controller.__create_adapters__"></a>
        <a name="__create_adapters__"></a>
        <div class="functionHeader">
        
        def __create_adapters__(self, prop_name, wid_name):
        
      </div>
        <div class="functionBody">
          
          <div>Private service that looks at property and widgets types, and possibly 
creates one or more (best) fitting adapters that are returned as a 
list.
<table class="fieldTable"></table></div>
        </div>
      </div>
    
    <address>
      <a href="index.html">API Documentation</a> for vodafone-mobile-connect-card-driver-for-linux, generated by <a href="http://codespeak.net/~mwh/pydoctor/">pydoctor</a> at 2008-01-10 13:06:31.
    </address>
  </body>
</html>