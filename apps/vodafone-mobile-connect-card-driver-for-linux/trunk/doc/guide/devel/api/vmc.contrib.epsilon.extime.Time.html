<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>API docs for &ldquo;vmc.contrib.epsilon.extime.Time&rdquo;</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
    
    
  </head>
  <body>
    <h1 class="class">Class v.c.e.e.Time(<span title="object">object</span>):</h1>
    <p>
      <span id="part">Part of <a href="vmc.html">vmc</a>.<a href="vmc.contrib.html">contrib</a>.<a href="vmc.contrib.epsilon.html">epsilon</a>.<a href="vmc.contrib.epsilon.extime.html">extime</a></span>
      
      <a href="classIndex.html#vmc.contrib.epsilon.extime.Time">View In Hierarchy</a>
    </p>
    <div>
      
    </div>
    <div><p>An object representing a well defined instant in time.</p>
<p>A Time object unambiguously addresses some time, independent of 
timezones, contorted base-60 counting schemes, leap seconds, and the 
effects of general relativity. It provides methods for returning a 
representation of this time in various ways that a human or a programmer 
might find more useful in various applications.</p>
<p>Every Time instance has an attribute 'resolution'. This can be ignored, 
or the instance can be considered to address a span of time. This 
resolution is determined by the value used to initalize the instance, or 
the resolution of the internal representation, whichever is greater. It is 
mostly useful when using input formats that allow the specification of 
whole days or weeks. For example, ISO 8601 allows one to state a time as, 
&quot;2005-W03&quot;, meaning &quot;the third week of 2005&quot;. In this 
case the resolution is set to one week. Other formats are considered to 
express only an instant in time, such as a POSIX timestamp, because the 
resolution of the time is limited only by the hardware's representation of 
a real number.</p>
<p>Timezones are significant only for instances with a resolution greater 
than one day. When the timezone is insignificant, the result of methods 
like asISO8601TimeAndDate is the same for any given tzinfo parameter. Sort 
order is determined by the start of the period in UTC. For example, 
&quot;today&quot; sorts after &quot;midnight today, central Europe&quot;, 
and before &quot;midnight today, US Eastern&quot;. For applications that 
need to store a mix of timezone dependent and independent instances, it may
be wise to store them separately, since the time between the start and end 
of today in the local timezone may not include the start of today in UTC, 
and thus not independent instances addressing the whole day. In other 
words, the desired sort order (the one where just &quot;Monday&quot; sorts 
before any more precise time in &quot;Monday&quot;, and after any in 
&quot;Sunday&quot;) of Time instances is dependant on the timezone 
context.</p>
<p>Date arithmetic and boolean operations operate on instants in time, not 
periods. In this case, the start of the period is used as the value, and 
the result has a resolution of 0.</p>
<p>For containment tests with the 'in' operator, the period addressed by 
the instance is used.</p>
<p>The methods beginning with 'from' are constructors to create instances 
from various formats. Some of them are textual formats, and others are 
other time types commonly found in Python code.</p>
<p>Likewise, methods beginning with 'as' return the represented time in 
various formats. Some of these methods should try to reflect the resolution
of the instance. However, they don't yet.</p>
For formats with both a constructor and a formatter, d == 
fromFu(d.asFu())
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Instance Variables</td><td class="fieldArg">resolution</td><td>the length of the period to which this instance could refer. For 
example, &quot;Today, 13:38&quot; could refer to any time between 13:38 
until but not including 13:39. In this case resolution would be 
timedelta(minutes=1).
 (type: datetime.timedelta
)</td></tr></table></div>
    
    
    <div id="splitTables">
      <table class="children sortable" id="id720">
  
  
  
  
  <tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#__init__">__init__</a></td>
    <td><span>Return a new Time instance representing the time now.
</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#fromHumanly">fromHumanly</a></td>
    <td><span>Return a new Time instance from a string a human might type.
</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#fromISO8601TimeAndDate">fromISO8601TimeAndDate</a></td>
    <td><span>Return a new Time instance from a string formated as in ISO 8601.
</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#fromStructTime">fromStructTime</a></td>
    <td><span>Return a new Time instance from a time.struct_time.
</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#fromDatetime">fromDatetime</a></td>
    <td><span>Return a new Time instance from a datetime.datetime instance.
</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#fromPOSIXTimestamp">fromPOSIXTimestamp</a></td>
    <td><span>Return a new Time instance from seconds since the POSIX epoch.
</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#fromRFC2822">fromRFC2822</a></td>
    <td><span>Return a new Time instance from a string formated as described in RFC 
2822.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#asPOSIXTimestamp">asPOSIXTimestamp</a></td>
    <td><span>Return this time as a timestamp as specified by POSIX.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#asDatetime">asDatetime</a></td>
    <td><span>Return this time as an aware datetime.datetime instance.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#asNaiveDatetime">asNaiveDatetime</a></td>
    <td><span>Return this time as a naive datetime.datetime instance.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#asRFC2822">asRFC2822</a></td>
    <td><span>Return this Time formatted as specified in RFC 2822.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#asISO8601TimeAndDate">asISO8601TimeAndDate</a></td>
    <td><span>Return this time formatted as specified by ISO 8861.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#asStructTime">asStructTime</a></td>
    <td><span>Return this time represented as a time.struct_time.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#asHumanly">asHumanly</a></td>
    <td><span>Return this time as a short string, tailored to the current time.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#getBounds">getBounds</a></td>
    <td><span>Return a pair describing the bounds of self.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#oneDay">oneDay</a></td>
    <td><span>Return a Time instance representing the day of the start of self.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#isAllDay">isAllDay</a></td>
    <td><span>Return True iff this instance represents exactly all day.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#isTimezoneDependent">isTimezoneDependent</a></td>
    <td><span>Return True iff timezone is relevant for this instance.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#__cmp__">__cmp__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#__eq__">__eq__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#__ne__">__ne__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#__repr__">__repr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#__contains__">__contains__</a></td>
    <td><span>Test if another Time instance is entirely within the period addressed by
this one.
</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#__add__">__add__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="vmc.contrib.epsilon.extime.Time.html#__sub__">__sub__</a></td>
    <td><span>Implement subtraction of an interval or another time from this one.
</span></td>
  </tr>
  
</table>
      
      
    </div>
    
    
    
    <div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.__init__"></a>
        <a name="__init__"></a>
        <div class="functionHeader">
        
        def __init__(self):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return a new Time instance representing the time now.</p>
See also the fromFu methods to create new instances from other types of 
initializers.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time._fromWeekday"></a>
        <a name="_fromWeekday"></a>
        <div class="functionHeader">
        @classmethod<br />
        def _fromWeekday(klass, match, tzinfo, now):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time._fromTodayOrTomorrow"></a>
        <a name="_fromTodayOrTomorrow"></a>
        <div class="functionHeader">
        @classmethod<br />
        def _fromTodayOrTomorrow(klass, match, tzinfo, now):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time._fromTime"></a>
        <a name="_fromTime"></a>
        <div class="functionHeader">
        @classmethod<br />
        def _fromTime(klass, match, tzinfo, now):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time._fromNoonOrMidnight"></a>
        <a name="_fromNoonOrMidnight"></a>
        <div class="functionHeader">
        @classmethod<br />
        def _fromNoonOrMidnight(klass, match, tzinfo, now):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time._fromNow"></a>
        <a name="_fromNow"></a>
        <div class="functionHeader">
        @classmethod<br />
        def _fromNow(klass, match, tzinfo, now):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.fromHumanly"></a>
        <a name="fromHumanly"></a>
        <div class="functionHeader">
        @classmethod<br />
        def fromHumanly(klass, humanStr, tzinfo=None, now=None):
        
      </div>
        <div class="functionBody">
          
          <div>Return a new Time instance from a string a human might type.
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">humanStr</td><td>the string to be parsed.
</td></tr><tr><td></td><td class="fieldArg">tzinfo</td><td>A tzinfo instance indicating the timezone to assume if none is specified
in humanStr. If None, assume UTC.
</td></tr><tr><td></td><td class="fieldArg">now</td><td><p>A Time instance to be considered &quot;now&quot; for when interpreting 
relative dates like &quot;tomorrow&quot;. If None, use the real now.</p>
Total crap now, it just supports weekdays, &quot;today&quot; and 
&quot;tomorrow&quot; for now. This is pretty insufficient and useless, but 
good enough for some demo functionality, or something.
</td></tr></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.fromISO8601TimeAndDate"></a>
        <a name="fromISO8601TimeAndDate"></a>
        <div class="functionHeader">
        @classmethod<br />
        def fromISO8601TimeAndDate(klass, iso8601string, tzinfo=None):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return a new Time instance from a string formated as in ISO 8601.</p>
<p>If the given string contains no timezone, it is assumed to be in the 
timezone specified by the parameter `tzinfo`, or UTC if tzinfo is None. An 
input string with an explicit timezone will always override tzinfo.</p>
<p>If the given iso8601string does not contain all parts of the time, they 
will default to 0 in the timezone given by `tzinfo`.</p>
WARNING: this function is incomplete. ISO is dumb and their standards 
are not free. Only a subset of all valid ISO 8601 dates are parsed, because
I can't find a formal description of the format. However, common ones 
should work.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.fromStructTime"></a>
        <a name="fromStructTime"></a>
        <div class="functionHeader">
        @classmethod<br />
        def fromStructTime(klass, structTime, tzinfo=None):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return a new Time instance from a time.struct_time.</p>
<p>If tzinfo is None, structTime is in UTC. Otherwise, tzinfo is a 
datetime.tzinfo instance coresponding to the timezone in which structTime 
is.</p>
Many of the functions in the standard time module return these things. 
This will also work with a plain 9-tuple, for parity with the time module. 
The last three elements, or tm_wday, tm_yday, and tm_isdst are ignored.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.fromDatetime"></a>
        <a name="fromDatetime"></a>
        <div class="functionHeader">
        @classmethod<br />
        def fromDatetime(klass, dtime):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return a new Time instance from a datetime.datetime instance.</p>
If the datetime instance does not have an associated timezone, it is 
assumed to be UTC.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.fromPOSIXTimestamp"></a>
        <a name="fromPOSIXTimestamp"></a>
        <div class="functionHeader">
        @classmethod<br />
        def fromPOSIXTimestamp(klass, secs):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return a new Time instance from seconds since the POSIX epoch.</p>
The POSIX epoch is midnight Jan 1, 1970 UTC. According to POSIX, leap 
seconds don't exist, so one UTC day is exactly 86400 seconds, even if it 
wasn't.
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">secs</td><td>a number of seconds, represented as an integer, long or float.
</td></tr></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.fromRFC2822"></a>
        <a name="fromRFC2822"></a>
        <div class="functionHeader">
        @classmethod<br />
        def fromRFC2822(klass, rfc822string):
        
      </div>
        <div class="functionBody">
          
          <div>Return a new Time instance from a string formated as described in RFC 
2822.
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">rfc822string</td><td> (type: str
)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a new <a 
href="vmc.contrib.epsilon.extime.Time.html"><code>Time</code></a>
</td></tr><tr class="fieldStart"><td class="fieldName">Raises</td><td class="fieldArg">ValueError</td><td>if the timestamp is not formatted properly (or if certain obsoleted 
elements of the specification are used).
</td></tr></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.asPOSIXTimestamp"></a>
        <a name="asPOSIXTimestamp"></a>
        <div class="functionHeader">
        
        def asPOSIXTimestamp(self):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return this time as a timestamp as specified by POSIX.</p>
This timestamp is the count of the number of seconds since Midnight, Jan
1 1970 UTC, ignoring leap seconds.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.asDatetime"></a>
        <a name="asDatetime"></a>
        <div class="functionHeader">
        
        def asDatetime(self, tzinfo=None):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return this time as an aware datetime.datetime instance.</p>
The returned datetime object has the specified tzinfo, or a tzinfo 
describing UTC if the tzinfo parameter is None.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.asNaiveDatetime"></a>
        <a name="asNaiveDatetime"></a>
        <div class="functionHeader">
        
        def asNaiveDatetime(self, tzinfo=None):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return this time as a naive datetime.datetime instance.</p>
The returned datetime object has its tzinfo set to None, but is in the 
timezone given by the tzinfo parameter, or UTC if the parameter is 
None.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.asRFC2822"></a>
        <a name="asRFC2822"></a>
        <div class="functionHeader">
        
        def asRFC2822(self, tzinfo=None, includeDayOfWeek=True):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return this Time formatted as specified in RFC 2822.</p>
<p>RFC 2822 specifies the format of email messages.</p>
<p>RFC 2822 says times in email addresses should reflect the local 
timezone. If tzinfo is a datetime.tzinfo instance, the returned formatted 
string will reflect that timezone. Otherwise, the timezone will be '-0000',
which RFC 2822 defines as UTC, but with an unknown local timezone.</p>
RFC 2822 states that the weekday is optional. The parameter 
includeDayOfWeek indicates whether or not to include it.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.asISO8601TimeAndDate"></a>
        <a name="asISO8601TimeAndDate"></a>
        <div class="functionHeader">
        
        def asISO8601TimeAndDate(self, includeDelimiters=True, tzinfo=None, includeTimezone=True):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return this time formatted as specified by ISO 8861.</p>
<p>ISO 8601 allows optional dashes to delimit dates and colons to delimit 
times. The parameter includeDelimiters (default True) defines the inclusion
of these delimiters in the output.</p>
<p>If tzinfo is a datetime.tzinfo instance, the output time will be in the 
timezone given. If it is None (the default), then the timezone string will 
not be included in the output, and the time will be in UTC.</p>
The includeTimezone parameter coresponds to the inclusion of an explicit
timezone. The default is True.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.asStructTime"></a>
        <a name="asStructTime"></a>
        <div class="functionHeader">
        
        def asStructTime(self, tzinfo=None):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return this time represented as a time.struct_time.</p>
tzinfo is a datetime.tzinfo instance coresponding to the desired 
timezone of the output. If is is the default None, UTC is assumed.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.asHumanly"></a>
        <a name="asHumanly"></a>
        <div class="functionHeader">
        
        def asHumanly(self, tzinfo=None, now=None):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return this time as a short string, tailored to the current time.</p>
<p>Parts of the date that can be assumed are omitted. Consequently, the 
output string depends on the current time. This is the format used for 
displaying dates in most user visible places in the quotient web UI.</p>
By default, the current time is determined by the system clock. The 
current time used for formatting the time can be changed by providing a 
Time instance as the parameter 'now'.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.getBounds"></a>
        <a name="getBounds"></a>
        <div class="functionHeader">
        
        def getBounds(self, tzinfo=None):
        
      </div>
        <div class="functionBody">
          
          <pre>Return a pair describing the bounds of self.

This returns a pair (min, max) of Time instances. It is not quite the
same as (self, self + self.resolution). This is because timezones are
insignificant for instances with a resolution greater or equal to 1
day.

To illustrate the problem, consider a Time instance:

    T = Time.fromHumanly('today', tzinfo=anything)

This will return an equivalent instance independent of the tzinfo used.
The hour, minute, and second of this instance are 0, and its resolution
is one day.

Now say we have a sorted list of times, and we want to get all times
for 'today', where whoever said 'today' is in a timezone that's 5 hours
ahead of UTC. The start of 'today' in this timezone is UTC 05:00. The
example instance T above is before this, but obviously it is today.

The min and max times this returns are such that all potentially
matching instances are within this range. However, this range might
contain unmatching instances.

As an example of this, if 'today' is April first 2005, then
Time.fromISO8601TimeAndDate('2005-04-01T00:00:00') sorts in the same
place as T from above, but is not in the UTC+5 'today'.

TIME IS FUN!</pre>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.oneDay"></a>
        <a name="oneDay"></a>
        <div class="functionHeader">
        
        def oneDay(self):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return a Time instance representing the day of the start of self.</p>
The returned new instance will be set to midnight of the day containing 
the first instant of self in the specified timezone, and have a resolution 
of datetime.timedelta(days=1).
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.isAllDay"></a>
        <a name="isAllDay"></a>
        <div class="functionHeader">
        
        def isAllDay(self):
        
      </div>
        <div class="functionBody">
          
          <div>Return True iff this instance represents exactly all day.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.isTimezoneDependent"></a>
        <a name="isTimezoneDependent"></a>
        <div class="functionHeader">
        
        def isTimezoneDependent(self):
        
      </div>
        <div class="functionBody">
          
          <div><p>Return True iff timezone is relevant for this instance.</p>
Timezone is only relevent for instances with a resolution better than 
one day.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.__cmp__"></a>
        <a name="__cmp__"></a>
        <div class="functionHeader">
        
        def __cmp__(self, other):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.__eq__"></a>
        <a name="__eq__"></a>
        <div class="functionHeader">
        
        def __eq__(self, other):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.__ne__"></a>
        <a name="__ne__"></a>
        <div class="functionHeader">
        
        def __ne__(self, other):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.__repr__"></a>
        <a name="__repr__"></a>
        <div class="functionHeader">
        
        def __repr__(self):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.__contains__"></a>
        <a name="__contains__"></a>
        <div class="functionHeader">
        
        def __contains__(self, other):
        
      </div>
        <div class="functionBody">
          
          <div>Test if another Time instance is entirely within the period addressed by
this one.
<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.__add__"></a>
        <a name="__add__"></a>
        <div class="functionHeader">
        
        def __add__(self, addend):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="vmc.contrib.epsilon.extime.Time.__sub__"></a>
        <a name="__sub__"></a>
        <div class="functionHeader">
        
        def __sub__(self, subtrahend):
        
      </div>
        <div class="functionBody">
          
          <div>Implement subtraction of an interval or another time from this one.
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">subtrahend</td><td>The object to be subtracted from this one.
 (type: <code>datetime.timedelta</code> or <a 
href="vmc.contrib.epsilon.extime.Time.html"><code>Time</code></a>
)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">If <code>subtrahend</code> is a <code>datetime.timedelta</code>, the 
result is a <a 
href="vmc.contrib.epsilon.extime.Time.html"><code>Time</code></a> instance 
which is offset from this one by that amount.  If <code>subtrahend</code> 
is a <a href="vmc.contrib.epsilon.extime.Time.html"><code>Time</code></a>, 
the result is a <code>datetime.timedelta</code> instance which gives the 
difference between it and this <a 
href="vmc.contrib.epsilon.extime.Time.html"><code>Time</code></a> 
instance.
 (type: <code>datetime.timedelta</code> or <a 
href="vmc.contrib.epsilon.extime.Time.html"><code>Time</code></a>
)</td></tr></table></div>
        </div>
      </div>
    
    <address>
      <a href="index.html">API Documentation</a> for vodafone-mobile-connect-card-driver-for-linux, generated by <a href="http://codespeak.net/~mwh/pydoctor/">pydoctor</a> at 2008-01-10 13:06:31.
    </address>
  </body>
</html>