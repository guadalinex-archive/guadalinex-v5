# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007  Vodafone España, S.A.
# Author:  Pablo Martí
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""VMC's notifications"""

__version__ = "$Rev: 1172 $"

from zope.interface import implements
from twisted.python import log

from vmc.common.plugin import PluginManager
from vmc.common.interfaces import INotificationPlugin, INotificationListener

# SIGNALS
SIG_CONNECTED = 'connected'
SIG_DEVICE_ADDED = 'added'
SIG_DEVICE_REMOVED = 'removed'
SIG_DISCONNECTED = 'disconnected'
SIG_INVALID_DNS = 'invalid_dns'
SIG_NEW_CONN_MODE = 'new_conn_mode'
SIG_CALL = 'call'
SIG_CREG = 'creg'
SIG_RSSI = 'rssi'
SIG_SMS = 'sms'
SIG_SPEED = 'speed'
SIG_TIMEOUT = 'timeout'
SIG_CONN = 'conn'

NO_SIGNAL = 'NO_SIGNAL'
GPRS_SIGNAL = 'GPRS_SIGNAL'
UMTS_SIGNAL = 'UMTS_SIGNAL'
HSDPA_SIGNAL = 'HSDPA_SIGNAL'
HSUPA_SIGNAL = 'HSUPA_SIGNAL'
HSPA_SIGNAL = 'HSPA_SIGNAL'

THREEG_SIGNALS = [UMTS_SIGNAL, HSDPA_SIGNAL, HSUPA_SIGNAL, HSPA_SIGNAL]


class Notification(object):
    """Base class for Notifications"""
    def __init__(self, _type, args):
        super(Notification, self).__init__()
        self.type = _type
        self.args = args

class ConnectionNotification(Notification):
    """
    Notification fired with connection events
    """
    def __init__(self, _type):
        super(ConnectionNotification, self).__init__(SIG_CONN, _type)
    
    def __repr__(self):
        stuff = (self.__class__.__name__, id(self), self.args)
        return '<%s at 0x%x status: %s>' % stuff
        
class UnsolicitedNotification(Notification):
    """
    I'm generated in some devices that like to send unsolicited notifications
    """
    def __init__(self, _type, args):
        super(UnsolicitedNotification, self).__init__(_type, args)
    
    def __repr__(self):
        stuff = (self.__class__.__name__, self.type, self.args)
        return '<%s type: %s args: %s>' % stuff
    
    def __eq__(self, n):
        return self.type == n.type and self.args == n.args
    
    def __ne__(self, n):
        return not (self.type == n.type and self.args == n.args)


class NetworkRegNotification(Notification):
    """
    I'm generated by +CREG=int,int events
    """
    def __init__(self, status):
        super(NetworkRegNotification, self).__init__(SIG_CREG, status)
    
    def __repr__(self):
        stuff = (self.__class__.__name__, id(self), self.args)
        return '<%s at 0x%x status: %d>' % stuff


class NewSMSArrived(Notification):
    """
    I'm generated whenever a new SMS arrives
    """
    def __init__(self, index, where):
        args = index, where
        super(NewSMSArrived, self).__init__(SIG_SMS, args)
    
    def __repr__(self):
        index, where = self.args
        stuff = (self.__class__.__name__, id(self), index, where)
        return '<%s at 0x%x index: %d at "%s">' % stuff


class CallNotification(Notification):
    """
    I represent a call from a number
    """
    
    def __init__(self):
        super(CallNotification, self).__init__(SIG_CALL, None)
    
    def __repr__(self):
        return '<%s at 0x%x>' % (self.__class__.__name__, id(self))


class NotificationsManager(object):
    """
    I manage the notifications produced in the communications block
    """
    implements(INotificationListener)
    
    def __init__(self, wrapper, device, kwds):
        super(NotificationsManager, self).__init__()
        self.wrapper = wrapper
        self.queue = device.sconn.notifications
        self.listeners = []
        self.plugin_listeners = [p for p in PluginManager.get_plugins(
                                                INotificationPlugin)]
        self.running = False
        self.signal_map = {}
        self.setup_signals(kwds)
    
    def setup_signals(self, kwds):
        self.signal_map.update(kwds)
    
    def add_listener(self, listener):
        self.listeners.append(listener)
    
    def remove_listener(self, listener):
        self.listeners.remove(listener)
    
    def start(self):
        if self.running:
            return
        
        self.running = True
        self.check_queue()
    
    def stop(self):
        self.running = False
    
    def check_queue(self):
        self.queue.get().addCallback(self.on_notification_received)
    
    def on_notification_received(self, notification):
        """
        Executed whenever a notification is pushed into the queue
        
        I will notify all my listeners every time a notification is received
        """
        # Notify listeners (SMs)
        for listener in self.listeners:
            listener.on_notification_received(notification)
        
        # Notify Plugin Listeners
        for listener in self.plugin_listeners:
            if notification.type == listener.type:
                # INotificationPlugin receives a wrapper reference and the
                # notification itself
                try:
                    listener.on_notification_received(self.wrapper,
                                                      notification)
                except:
                    log.err()
        
        # If we have a handler for the notification, execute it
        if notification.type in self.signal_map:
            handler = self.signal_map[notification.type]
            if handler:
                try:
                    handler(notification.args)
                except:
                    log.err()
        else:
            args = (notification, self.signal_map)
            log.err("Notification %s not in %s" % args)
        
        # check queue for next notification
        self.check_queue()

